<div class="white container-fluid py-5">
    <div class="container">
		<h1>Prototypes and Prolog objects</h1>
		<p>In this page, the Javascript prototypes used for modelling Prolog's elements and methods can be found.</p>
	</div>
</div>

<div class="white container-fluid py-5">
    <div class="container">
		<h2 id="variables"><a href="#variables">Variables</a></h2>
		<p>In order to represent the logical variables in a Prolog program, the prototype <span class="inline-code">pl.type.Var</span> is used. The only argument that the constructor receives is the id of the variable as a string.</p>
		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var, this);"><b>pl.type.Var</b></a>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.toString, this);">pl.type.Var.prototype.<b>toString()</b></a> - Return a string representation of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.clone, this);">pl.type.Var.prototype.<b>clone()</b></a> - Return a copy of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.compare, this);">pl.type.Var.prototype.<b>compare(object)</b></a> - Compare two objects. Return <span class="inline-code">-1</span> if <span class="inline-code">Var</span> is smaller than <span class="inline-code">object</span>, <span class="inline-code">0</span> if both objects are the same and <span class="inline-code">1</span> if <span class="inline-code">Var</span> is bigger than object. This method is exclusively used for comparing <strong>variables</strong>. There is an order relationship defined among the Prolog objects. <span class="inline-code">pl.compare</span> can be used to compare any couple of Prolog objects.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.rename, this);">pl.type.Var.prototype.<b>rename(thread)</b></a> - Rename the object. Return a fresh variable for the thread <span class="inline-code">thread</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.variables, this);">pl.type.Var.prototype.<b>variables()</b></a> - Return the object's list of variables. Return a single-element list containing the id of the variable.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.apply, this);">pl.type.Var.prototype.<b>apply(substitution)</b></a> - Apply a substitution to the object. Return the new value of the variable after applying the substitution, or the previous value if there was no substitution.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.unify, this);">pl.type.Var.prototype.<b>unify(object, occurs_check)</b></a> - Return the state resulting from unifying both objects if this succeeds, <span class="inline-code">null</span> otherwise. The second argument indicates wheter it must check for the variable itself inside of <span class="inline-code">object</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.interpret, this);">pl.type.Var.prototype.<b>interpret(thread)</b></a> - Return the result of assessing the object arithmetically. If the calling object is a <span class="inline-code">Var</span>, it throws an <span class="inline-code">instatiation_error</span> in <span class="inline-code">thread</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.compile, this);">pl.type.Var.prototype.<b>compile()</b></a> - Return as a string the JavaScript code needed to generate the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.equals, this);">pl.type.Var.prototype.<b>equals(object)</b></a> - Return <span class="inline-code">true</span> if the variable and <span class="inline-code">object</span> are equal, checking that the internal attributes in both of them are equal as well.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Var.prototype.toJavaScript, this);">pl.type.Var.prototype.<b>toJavaScript()</b></a> - Return the Prolog object as a JavaScript object. If the object is a <span class="inline-code">Var</span>, it returns <span class="inline-code">undefined</span>.</li>
		</ul>

		<h2 id="terms" class="mt-5"><a href="#terms">Terms</a></h2>
		<p>The <span class="inline-code">pl.type.Term</span> prototype is used to represent atoms and compound terms in Prolog programs. The constructor receives a string identifying the term and, if the term is compound, a list of Prolog objects.</p>
		<p>List are made up of <span class="inline-code">./2</span> terms, which receive a head and a tail, and the <span class="inline-code">[]/0</span> term, used to represent an empty list. For instance, the list <span class="inline-code">[1,2,3]</span> is analysed as <span class="inline-code">'.'(1,'.'(2,'.'(3,[])))</span>.</p>

		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term, this);"><b>pl.type.Term</b></a>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.toString, this);">pl.type.Term.prototype.<b>toString()</b></a> - Return a string representation of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.clone, this);">pl.type.Term.prototype.<b>clone()</b></a> - Return a copy of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.compare, this);">pl.type.Term.prototype.<b>compare(object)</b></a> - Compare two objects. Return <span class="inline-code">-1</span> if <span class="inline-code">Term</span> is smaller than <span class="inline-code">object</span>, <span class="inline-code">0</span> if both objects are the same and <span class="inline-code">1</span> if <span class="inline-code">Term</span> is bigger than object. This method is exclusively used for comparing <strong>terms</strong>. There is an order relationship defined among the Prolog objects. <span class="inline-code">pl.compare</span> can be used to compare any couple of Prolog objects.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.rename, this);">pl.type.Term.prototype.<b>rename(thread)</b></a> - Rename the object. Return a term with fresh variables for the thread <span class="inline-code">thread</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.variables, this);">pl.type.Term.prototype.<b>variables()</b></a> - Return a list of the variables contained in term, if any.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.apply, this);">pl.type.Term.prototype.<b>apply(substitution)</b></a> - Apply a substitution to the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.unify, this);">pl.type.Term.prototype.<b>unify(object, occurs_check)</b></a> - Return the state resulting from unifying both objects if this succeeds, <span class="inline-code">null</span> otherwise. The second argument indicates wheter it must check the variables inside of <span class="inline-code">object</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.select, this);">pl.type.Term.prototype.<b>select()</b></a> - Return the leftmost atom of the term.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.replace, this);">pl.type.Term.prototype.<b>replace(object)</b></a> - Replace the leftmost atom with the object passed as an argument. If this is <span class="inline-code">null</span>, the leftmost atom is removed.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.search, this);">pl.type.Term.prototype.<b>search(object)</b></a> - Check if the atom passed as an argument is inside of the term.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.interpret, this);">pl.type.Term.prototype.<b>interpret(thread)</b></a> - Return the result of assessing the object arithmetically. If the calling object is a <span class="inline-code">Term</span>, and it stands for an evaluable functor, it returns the result of assessing the term with its arguments. Interpreting a term can throw an error in the <span class="inline-code">thread</span> argument (due to the incorrect type of the arguments, division by zero, etc.)</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.compile, this);">pl.type.Term.prototype.<b>compile()</b></a> - Return as a string the JavaScript code needed to generate the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.equals, this);">pl.type.Term.prototype.<b>equals(object)</b></a> - Return <span class="inline-code">true</span> if the term and <span class="inline-code">object</span> are equal, checking that the internal attributes in both of them are equal as well.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Term.prototype.toJavaScript, this);">pl.type.Term.prototype.<b>toJavaScript()</b></a> - Return the Prolog object as a JavaScript object. If the calling object is <span class="inline-code">Term</span>: if the term is a well-formed list, it returns a JavaScript array; if the term is atomic, it returns its id as a string; in any other case, it returns <span class="inline-code">undefined</span>.</li>
		</ul>

		<h2 id="numbers" class="mt-5"><a href="#numbers">Numbers</a></h2>
		<p>The <span class="inline-code">pl.type.Num</span> prototype is used to represent numbers in Prolog problems. The constructor receives two arguments: the number representing the numeric value and a boolean object which indicates if the number is a real value (<span class="inline-code">true</span>) or not (<span class="inline-code">false</span>), and then, integer.</p>
		<p>Integers are limited to the biggest number that JavaScript can represent reliably, <span class="inline-code">2<sup>53</sup> - 1</span> = <span class="inline-code">9007199254740991</span> <span class="manual-annotation">(see <a href="https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER" target="_blank">[Number.MAX_SAFE_INTEGER]</a> of JavaScript)</span>. Any operation which exceeds that value will return an overflow evaluation error.</p>
		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num, this);"><b>pl.type.Num</b></a>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.toString, this);">pl.type.Num.prototype.<b>toString()</b></a> - Return a string representation of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.clone, this);">pl.type.Num.prototype.<b>clone()</b></a> - Return a copy of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.compare, this);">pl.type.Num.prototype.<b>compare(object)</b></a> - Compare two objects. Return <span class="inline-code">-1</span> if <span class="inline-code">Num</span> is smaller than <span class="inline-code">object</span>, <span class="inline-code">0</span> if both objects are the same and <span class="inline-code">1</span> if <span class="inline-code">Num</span> is bigger than object. This method is exclusively used for comparing <strong>numbers</strong>. There is an order relationship defined among the Prolog objects. <span class="inline-code">pl.compare</span> can be used to compare any couple of Prolog objects.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.rename, this);">pl.type.Num.prototype.<b>rename(thread)</b></a> - Rename the object. Return the same object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.variables, this);">pl.type.Num.prototype.<b>variables()</b></a> - Return the object's list of variables. Return an empty list. </li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.apply, this);">pl.type.Num.prototype.<b>apply(substitution)</b></a> - Apply a substitution to the object. Return the same object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.unify, this);">pl.type.Num.prototype.<b>unify(object, occurs_check)</b></a> - Return the state resulting from unifying both objects if this succeeds, <span class="inline-code">null</span> otherwise. The second argument indicates wheter it must check the variables inside of <span class="inline-code">object</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.interpret, this);">pl.type.Num.prototype.<b>interpret(thread)</b></a> - Return the result of assessing the object arithmetically. If the calling object is a is a <span class="inline-code">Num</span>, it returns that number. </li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.compile, this);">pl.type.Num.prototype.<b>compile()</b></a> - Return as a string the JavaScript code needed to generate the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.equals, this);">pl.type.Num.prototype.<b>equals(object)</b></a> - Return <span class="inline-code">true</span> if the number and <span class="inline-code">object</span> are equal, checking that the internal attributes in both of them are equal as well.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Num.prototype.toJavaScript, this);">pl.type.Num.prototype.<b>toJavaScript()</b></a> - Return the Prolog object as a JavaScript object. If the object is a <span class="inline-code">Num</span>, it returns either an <span class="inline-code">integer</span> or a <span class="inline-code">float</span> number with the <span class="inline-code">Num</span> value.</li>
		</ul>

		<h2 id="substitutions" class="mt-5"><a href="#substitutions">Substitution</a></h2>
		<p>The <span class="inline-code">pl.type.Substitution</span> prototype is used to represent the substitutions in the resolution process, as well as in the Prolog programs. The constructor receives, optionally, a JavaScript object linking variables with objects. For instance, <span class="inline-code">new pl.type.Substitution({"X":new pl.type.Term("a"), "Y":new.pl.type.Num(2)});</span> is a substitution in which the <span class="inline-code">X</span> variable is replaced with <span class="inline-code">a</span> and the <span class="inline-code">Y</span> variable is replaced with<span class="inline-code">2</span>.</p>
		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution, this);"><b>pl.type.Substitution</b></a>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.toString, this);">pl.type.Substitution.prototype.<b>toString()</b></a> - Return a string representation of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.clone, this);">pl.type.Substitution.prototype.<b>clone()</b></a> - Return a copy of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.apply, this);">pl.type.Substitution.prototype.<b>apply(substitution)</b></a> - Apply a substitution to the object. Return the composition of both substitutions.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.lookup, this);">pl.type.Substitution.prototype.<b>lookup(variable)</b></a> - Look for a variable's value. Return <span class="inline-code">null</span> if the variable is not found.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.filter, this);">pl.type.Substitution.prototype.<b>filter(function)</b></a> - Return a new substitution filtered by the function received as argument.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.exclude, this);">pl.type.Substitution.prototype.<b>exclude(variables)</b></a> - Return a new substitution excluding the variables passed as arguments.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.add, this);">pl.type.Substitution.prototype.<b>add(variable, value)</b></a> - Add a new variable to the substitution.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.equals, this);">pl.type.Substitution.prototype.<b>equals(object)</b></a> - Return <span class="inline-code">true</span> if the substitution and <span class="inline-code">object</span> are equal, checking that the internal attributes in both of them are equal as well.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Substitution.prototype.domain, this);">pl.type.Substitution.prototype.<b>domain(plain)</b></a> - Return the domain of the substitution. If <span class="inline-code">plain</span> is <span class="inline-code">true</span>, the function returns a string list, each string being the id of each variable. In any other case, these variables are returned as an array of <span class="inline-code">pl.type.Var</span> objects.</li>
		</ul>

		<h2 id="states" class="mt-5"><a href="#states">States</a></h2>
		<p>The <span class="inline-code">pl.type.State</span> prototype is used to represent the choice points during the resolution process. The constructor receives a goal (a Prolog term) and a substitution. When the empty clause is reached, the goal is represented with the <span class="inline-code">null</span> value.</p>
		
		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.State, this);"><b>pl.type.State</b></a>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.State.prototype.toString, this);">pl.type.State.prototype.<b>toString()</b></a> - Return a string representation of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.State.prototype.clone, this);">pl.type.State.prototype.<b>clone()</b></a> - Return a copy of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.State.prototype.equals, this);">pl.type.State.prototype.<b>equals(object)</b></a> - Return <span class="inline-code">true</span> if state and <span class="inline-code">object</span> are equal, checking that the internal attributes in both of them are equal as well.</li>

		</ul>
		
		<h2 id="rules" class="mt-5"><a href="#rules">Rules</a></h2>
		<p>The <span class="inline-code">pl.type.Rule</span> prototype is used to represent the rules of Prolog programs. The constructor receives both the head and the tail of a rule as arguments. If the rule is a fact, the empty body is represented with a <span class="inline-code">null</span> value.</p>

		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule, this);"><b>pl.type.Rule</b></a>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule.prototype.toString, this);">pl.type.Rule.prototype.<b>toString()</b></a> - Return a string representation of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule.prototype.clone, this);">pl.type.Rule.prototype.<b>clone()</b></a> - Return a copy of the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule.prototype.rename, this);">pl.type.Rule.prototype.<b>rename(thread)</b></a> - Rename the object. Return the rule with fresh variables for the thread <span class="inline-code">thread</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule.prototype.variables, this);">pl.type.Rule.prototype.<b>variables()</b></a> - Return the object's list of variables.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule.prototype.apply, this);">pl.type.Rule.prototype.<b>apply(substitution)</b></a> - Apply a substitution to the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule.prototype.compile, this);">pl.type.Rule.prototype.<b>compile()</b></a> - Return as a string the JavaScript code needed to generate the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Rule.prototype.equals, this);">pl.type.Rule.prototype.<b>equals(object)</b></a> - Return <span class="inline-code">true</span> if the rule and <span class="inline-code">object</span> are equal, checking that the internal attributes in both of them are equal as well.</li>

		</ul>

		<h2 id="sessions" class="mt-5"><a href="#sessions">Sessions</a></h2>
		<p>The <span class="inline-code">pl.type.Session</span> prototype is used to represent sessions. The constructor receives an integer which sets the limit of resolution steps that the interpreter can take when trying to find an answer.</p>
		<p class="manual-warning"><b>Note</b>: In order to create a new session, the <span class="inline-code">pl.create</span> method is provided. It's not recommended to use the prototype directly <span class="manual-annotation">(see <a href="http://tau-prolog.org/manual/a-simple-tutorial#sessions">[A simple tutorial] #Sessions</a> from the Tau Prolog manual)
		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session, this);"><b>pl.type.Session</b></a></li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.add_rule, this);">pl.type.Session.prototype.<b>add_rule(rule)</b></a> - Add the rule to the session.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.run_directive, this);">pl.type.Session.prototype.<b>run_directive(directive)</b></a> - Run a directive in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.throw_warning, this);">pl.type.Session.prototype.<b>throw_warning(warning)</b></a> - Throw a warning in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.add_goal, this);">pl.type.Session.prototype.<b>add_goal(goal)</b></a> - Add the goal to the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.consult, this);">pl.type.Session.prototype.<b>consult(program)</b></a> - Analyse the <span class="inline-code">program</span> program and add the rules to the session's default thread. Return <span class="inline-code">true</span> if there is no errors.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.query, this);">pl.type.Session.prototype.<b>query(goal)</b></a> - Analyse the <span class="inline-code">goal</span> query and add it to the session's default thread. Return <span class="inline-code">true</span> if there is no errors.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.get_free_variable, this);">pl.type.Session.prototype.<b>get_free_variable(variable)</b></a> - Return a fresh version of a variable in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.next_free_variable, this);">pl.type.Session.prototype.<b>next_free_variable()</b></a> - Return the next free fresh variable in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.is_public_predicate, this);">pl.type.Session.prototype.<b>is_public_predicate(indicator)</b></a> - Check if a predicate in the session is public.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.prepend, this);">pl.type.Session.prototype.<b>prepend(states)</b></a> - Add state list to the session's default thread's choice points stack.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.success, this);">pl.type.Session.prototype.<b>success(point)</b></a> - Add a point to the session's default thread's choice points stack in which the chosen atom is removed.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.throw_error, this);">pl.type.Session.prototype.<b>throw_error(error)</b></a> - Throw an error in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.step, this);">pl.type.Session.prototype.<b>step()</b></a> - Execute a resolution step in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.answer, this);">pl.type.Session.prototype.<b>answer(callback)</b></a> - Look for an answer in the session's default thread. Run the callback with the found answer. If the interpreter exceeds the resolution steps limit, the callback will be called with the <span class="inline-code">null</span> value. If no answer is found, the callback will be called with the <span class="inline-code">false</span> value.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.answers, this);">pl.type.Session.prototype.<b>answers(callback, max)</b></a> - Look for <span class="inline-code">max</span> or less answers in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.again, this);">pl.type.Session.prototype.<b>again()</b></a> - Keep looking for an answer in the session's default thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.compile, this);">pl.type.Session.prototype.<b>compile()</b></a> - Return as a string the JavaScript code needed to generate the object.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.get_char_conversion, this);">pl.type.Session.prototype.<b>get_char_conversion(char)</b></a> - Return the character which stands for <span class="inline-code">char</span> as the session's <span class="inline-code">char_conversion</span> directive states.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.get_flag, this);">pl.type.Session.prototype.<b>get_flag(flag)</b></a> - Return the value set for the flag <span class="inline-code">flag</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.parse, this);">pl.type.Session.prototype.<b>parse(stream)</b></a> -  Parse the <span class="inline-code">stream</span> string and return the parsed expression <span class="inline-code">expr</span> and the tokens <span class="inline-code">tokens</span> generated during the lexial analysis.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.step_rule, this);">pl.type.Session.prototype.<b>step_rule(module, atom)</b></a> - Return session's rules as an array. If <span class="inline-code">module</span>, being it the name of a module as a string, is not <span class="inline-code">null</span>, it returns the predicate's clauses exported by  <span class="inline-code">module</span> whose atoms' indicators are the same as the <span class="inline-code">atom</span> one. If <span class="inline-code">module</span> is <span class="inline-code">null</span>, the function inspect the user-defined predicates and all the predicates from the imported modules looking for that said <span class="inline-code">atom</span> until it finds it and return its clauses.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.__get_max_priority, this);">pl.type.Session.prototype.<b>__get_max_priority()</b></a> - Return the highest priority of a session's operator.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.__get_next_priority, this);">pl.type.Session.prototype.<b>__get_next_priority(priority)</b></a> - Return the next highest priority below <span class="inline-code">priority</span> of a session's operator.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Session.prototype.__lookup_operator_classes, this);">pl.type.Session.prototype.<b>__lookup_operator_classes(priority, op)</b></a> - Return the <span class="inline-code">op</span> operator class in the priority level <span class="inline-code">priority</span> in the session (xfx, xfy, yfx, fy, etc.). If the <span class="inline-code">op</span> operator doesn't exist in that priority level, it returns <span class="inline-code">false</span>.</li>
		</ul>
		
		<h2 id="threads" class="mt-5"><a href="#threads">Threads</a></h2>
		<p>The <span class="inline-code">pl.type.Thread</span> prototype is used to represent running threads in the sessions. The constructor receives the session to which it belongs as an argument. When a session is created, it creates an inner thread by default. The threads of the same session share some information, as the parsed rules or the operators table, but elements as the goals or the choice points are thread-independent.</p>
		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread, this);"><b>pl.type.Thread</b></a></li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.add_rule, this);">pl.type.Thread.prototype.<b>add_rule(rule)</b></a> - Add the rule to the session it belongs to.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.run_directive, this);">pl.type.Thread.prototype.<b>run_directive(directive)</b></a> - Run a directive in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.throw_warning, this);">pl.type.Thread.prototype.<b>throw_warning(warning)</b></a> - Throw a warning in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.add_goal, this);">pl.type.Thread.prototype.<b>add_goal(goal)</b></a> - Add the goal to the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.consult, this);">pl.type.Thread.prototype.<b>consult(program)</b></a> - Analyse the <span class="inline-code">program</span> program and add the rules to the thread's session. Return <span class="inline-code">true</span> if there is no errors.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.query, this);">pl.type.Thread.prototype.<b>query(goal)</b></a> - Analyse the <span class="inline-code">goal</span> query and add it to the thread. Return <span class="inline-code">true</span> if there is no errors.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.get_free_variable, this);">pl.type.Thread.prototype.<b>get_free_variable(variable)</b></a> - Return a fresh version of a variable in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.next_free_variable, this);">pl.type.Thread.prototype.<b>next_free_variable()</b></a> - Return the next free fresh variable in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.is_public_predicate, this);">pl.type.Thread.prototype.<b>is_public_predicate(indicator)</b></a> - Check if a predicate is public in the session to which the thread belongs to.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.prepend, this);">pl.type.Thread.prototype.<b>prepend(states)</b></a> - Add state list to the thread's choice points stack.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.success, this);">pl.type.Thread.prototype.<b>success(point)</b></a> - Add a point to the thread's choice points stack in which the chosen atom is removed.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.throw_error, this);">pl.type.Thread.prototype.<b>throw_error(error)</b></a> - Throw an error in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.step, this);">pl.type.Thread.prototype.<b>step()</b></a> - Execute a resolution step in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.answer, this);">pl.type.Thread.prototype.<b>answer(callback)</b></a> - Look for an answer in the thread. Run the callback with the found answer. If the interpreter exceeds the resolution steps limit, the callback will be called with the <span class="inline-code">null</span> value. If no answer is found, the callback will be called with the <span class="inline-code">false</span> value.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.answers, this);">pl.type.Thread.prototype.<b>answers(callback, max)</b></a> - Look for <span class="inline-code">max</span> or less answers in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.again, this);">pl.type.Thread.prototype.<b>again()</b></a> - Keep looking for an answer in the thread.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.get_char_conversion, this);">pl.type.Thread.prototype.<b>get_char_conversion(char)</b></a> - Return the character which stands for <span class="inline-code">char</span> as the thread's <span class="inline-code">char_conversion</span> directive states.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.get_flag, this);">pl.type.Thread.prototype.<b>get_flag(flag)</b></a> - Return the value set for the flag <span class="inline-code">flag</span>.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.parse, this);">pl.type.Thread.prototype.<b>parse(stream)</b></a> -  Parse the <span class="inline-code">stream</span> string and return the parsed expression <span class="inline-code">expr</span> and the tokens <span class="inline-code">tokens</span> generated during the lexical analysis.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.step_rule, this);">pl.type.Thread.prototype.<b>step_rule(module, atom)</b></a> - Return session's rules as an array. If <span class="inline-code">module</span>, being it the name of a module as a string, is not <span class="inline-code">null</span>, it returns the predicate's clauses exported by  <span class="inline-code">module</span> whose atoms' indicators are the same as the <span class="inline-code">atom</span> one. If <span class="inline-code">module</span> is <span class="inline-code">null</span>, the function inspect the user-defined predicates and all the predicates from the imported modules looking for that said <span class="inline-code">atom</span> until it finds it and return its clauses.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.__get_max_priority, this);">pl.type.Thread.prototype.<b>__get_max_priority()</b></a> - Return the highest priority of a thread session's operator.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.__get_next_priority, this);">pl.type.Thread.prototype.<b>__get_next_priority(priority)</b></a> - Return the next highest priority below <span class="inline-code">priority</span> of a thread session's operator.</li>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Thread.prototype.__lookup_operator_classes, this);">pl.type.Thread.prototype.<b>__lookup_operator_classes(priority, op)</b></a> - Return the <span class="inline-code">op</span> operator class in the priority level <span class="inline-code">priority</span> in the thread session (xfx, xfy, yfx, fy, etc.). If the <span class="inline-code">op</span> operator doesn't exist in that priority level, it returns <span class="inline-code">false</span>.</li>
		</ul>

		<h2 id="modules" class="mt-5"><a href="#modules">Modules</a></h2>
		<p>The <span class="inline-code">pl.type.Module</span> prototype is used to represent the Prolog modules. The constructor receives the name of the module as a string and an object containing all its rules. This object has rule indicators as keys and rules lists as values.</p>
		
		<ul>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Module, this);"><b>pl.type.Module</b></a>
			<li><a role="button" tabindex="0" onClick="show_prototype(pl.type.Module.prototype.exports_predicate, this);">pl.type.Module.prototype.<b>exports_predicate(indicator)</b></a> - It checks wheter the module exports the predicate indicated by <span class="inline-code">indicator</span>.
		</ul>

		<h2 id="errors" class="mt-5"><a href="#errors">Errors</a></h2>
		<p>ISO Prolog provides with an exception handling mechanism, based on the built-in control constructions <a href="http://tau-prolog.org/documentation/prolog/builtin/catch/3">catch/3</a> y <a href="http://tau-prolog.org/documentation/prolog/builtin/throw/1">throw/1</a>. When there is an error, the current goal is replaced with a goal of the form <span class="inline-code">throw(error(Error_term, Implementation_defined_term))</span>. If the error is not handled, the error parameter in <span class="inline-code">throw/1</span> is returned.</p>
	</div>
</div>